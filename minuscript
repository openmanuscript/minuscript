#!/opt/local/bin/python

# ---------------------------------------------------------------------------
#
# minuscript, a minimal manuscript tool
#
# ---------------------------------------------------------------------------
"""
Copyright (c) 2016, David H. Rogers 
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
# ---------------------------------------------------------------------------

import argparse
import configparser
import json
import logging as log
import math
import os
import subprocess
import sys
import textwrap

# ---------------------------------------------------------------------------
#
# global variables
#
# ---------------------------------------------------------------------------
# this application
APP_NAME        = "minuscript"
APP_VERSION     = 1.0
APP_EXIT_ERROR  = 42
APP_BUILDDIR    = "buildtemp"
APP_SCENESDIR   = "scenes"
APP_START_PAGE_NUMBERING = 1
APP_TEXFILE     = "manuscript.tex"
APP_FORMAT      = "latex"
APP_FORMAT_EXT  = ".tex"

# external applications
APP_MMD         = "multimarkdown"
APP_LATEX       = "pdflatex"
APP_CP          = "cp"
APP_PS2ASCII    = "/opt/local/bin/ps2ascii"

# data
APP_INIT_AUTHOR_STRING = """{{ 
\"version\" : \"{version}\",
\"author\" : {{
    \"name\"      : \"Ima Q. Writer\",
    \"surname\"   : \"Writer\",
    \"email\"     : \"imaqwriter@imawriter.com\",
    \"phone\"     : \"(000) 000-0000\",
    \"website\"   : \"www.imawriter.com\",
    \"address\"   : \"111 Writer's Way\",
    \"city\"      : \"Writerville\",
    \"state\"     : \"NM\",
    \"zip\"       : \"88888\"
}}
}}""".format(version=APP_VERSION) 

APP_INIT_MANUSCRIPT_STRING = """{{
"version\" : \"{version}\",
\"manuscript\" : {{
    \"title\" : \"Initial Manuscript\",
    \"runningtitle\" : \"initial\",
    \"chapters\" : [
        {{
            \"title\"  : \"Example Chapter\",
            \"scenes\" : [\"lorem\", \"ipsum\"]
        }},
        {{
            \"title\"  : \"Another Example\",
            \"scenes\" : [\"lorem\"]
        }}
    ]
}}
}}""".format(version=APP_VERSION) 

APP_INIT_LOREM_TEXT = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam varius faucibus fermentum. Ut id nibh orci. Praesent posuere purus ac libero sagittis porttitor. Donec pulvinar sapien ligula, id ultrices ipsum interdum ac. Integer maximus lobortis nisl, eget vulputate erat ultricies id. Phasellus semper, massa sit amet porttitor finibus, mauris lacus placerat orci, in sagittis lectus leo sit amet sem. Fusce eu condimentum sapien. Proin sed sapien tortor. Donec viverra, erat eget elementum laoreet, ipsum ligula faucibus massa, non pellentesque est quam eget tellus." 

# ---------------------------------------------------------------------------
#
# write the inital files needed for a manuscript 
#
# ---------------------------------------------------------------------------
def write_initial_files( directory ):
    if  os.path.exists( APP_SCENESDIR ): 
        log.error(" {} exists; cannot continue - it looks like there's already a manuscript here.".format(APP_SCENESDIR) )
    else:
        with open( "author.json", 'w' ) as a:
            a.write( APP_INIT_AUTHOR_STRING )
        with open( "manuscript.json", 'w' ) as m:
            m.write( APP_INIT_MANUSCRIPT_STRING )
        os.makedirs( APP_SCENESDIR ) 
        with open( os.path.join( APP_SCENESDIR, "lorem.md" ), 'w' ) as l:
            l.write( APP_INIT_LOREM_TEXT )
            l.write( "\n\n" )
            l.write( APP_INIT_LOREM_TEXT )
            l.write( "\n\n" )
            l.write( APP_INIT_LOREM_TEXT )
        with open( os.path.join( APP_SCENESDIR, "ipsum.md" ), 'w' ) as i:
            i.write( APP_INIT_LOREM_TEXT )

# ---------------------------------------------------------------------------
#
# get initial settings from settings file, if there is one
#
# ---------------------------------------------------------------------------
conf_parser = argparse.ArgumentParser(
    # Turn off help, so we print all options in response to -h
    add_help=False
    )

args, remaining_argv = conf_parser.parse_known_args()

# you can set stuff here, but we're not  currently using this
# defaults = {
#     "sourcedir" : "defaultSourcedir",
#     "author"    : "defaultAuthor",
#     }

# SHORT CIRCUIT
# currently not implementing this, until the following work correctly:
#   1. full command line options
#   2. run-in-the-directory mode, in which the script is run in a 
#      manuscript directory, and all the data is local
#
#if args.conf_file:
#    config = ConfigParser.SafeConfigParser()
#    config.readfp(open(args.conf_file))
#    defaults = dict(config.items("Default"))


# ---------------------------------------------------------------------------
#
# command line options
#
# ---------------------------------------------------------------------------
# Don't surpress add_help here so it will handle -h
parser = argparse.ArgumentParser(
    # Don't mess with format of description
    formatter_class=argparse.RawDescriptionHelpFormatter,
    # Inherit options from config_parser
    parents=[conf_parser],
    # print script description with -h/--help
    epilog=textwrap.dedent('''\
        examples:
        
          minuscript (no args)
            will use the current directory as the manuscript directory.
            expects appropriate files in the current directory.

          minuscript --synopsis 
            will use the current directory as the manuscript directory,
            and create a manuscript with a synopsis before the first
            chapter. Expects a file named synopsis.md in the scenes
            directory.

          minuscript --synopsis --synopsisfile new-synopsis.md
            will use the current directory as the manuscript directory,
            and create a manuscript with a synopsis before the first
            chapter. Expects a file named new-synopsis.md in the scenes
            directory.
            ''')
)
# parser.set_defaults(**defaults)
parser.add_argument( "-d", "--debug", action="store_true", default=False,
    help="run in debug mode: create all files, but do not clean up after pdf is created.")
parser.add_argument( "-v", "--verbose", action="store_true", default=False,
    help="report verbosely")
parser.add_argument( "--author", default="notDefined",
    help="read author data from this file")
parser.add_argument( "--endnotes", action="store_true", default=False,
    help="write internal notes as endnotes")
parser.add_argument( "--chapsum", action="store_true", default=False,
    help="include chapter summaries, if they are present")
parser.add_argument( "--footnotes", action="store_true", default=False,
    help="write internal notes as footnotes")
parser.add_argument( "--fontfamily", default="pcr", 
    help="define the font family for the resulting pdf")
parser.add_argument( "--init", action="store_true", default=False,
    help="populate an initial minuscript project")
parser.add_argument( "--manuscriptname", default="notDefined", 
    help="name of the final pdf that will be created. This overrides the setting in the manuscript.json file")
parser.add_argument( "--manuscriptfile", default="manuscript.json", 
    help="read manuscript definition from this file")
parser.add_argument( "--nopdf", action="store_true", default=False,
    help="don't create pdf file. useful in debugging problems")
parser.add_argument( "--outline", action="store_true", default=False,
    help="print a simple outline of the manuscript and exit")
parser.add_argument( "--scenelist", action="store_true", default=False,
    help="print a simple scenelist of the manuscript and exit")
parser.add_argument( "--sourcedir", default="notDefined",
    help="use this as the root directory for the manuscript")
parser.add_argument( "--synopsis", action="store_true", default=False,
    help="include synopsis before the first chapter")
parser.add_argument( "--synopsisfile", default="synopsis.md", 
    help="if requested, read synopsis from this file")
parser.add_argument( "--toc", action="store_true", default=False,
    help="create table of contents")
parser.add_argument( "--version", action="version", version=APP_VERSION)
parser.add_argument( "--wordcount", action="store_true", default=False,
    help="add wordcount to title page")

args = parser.parse_args(remaining_argv)

# ---------------------------------------------------------------------------
#
# if the manuscript hasn't been set, the user may have run it in the 
# manuscript directory, so look for files locally 
#
# ---------------------------------------------------------------------------
if ( args.sourcedir == "notDefined" ):  
    args.sourcedir = os.getcwd() 

if ( args.author == "notDefined" ):  
    args.author = "author.json" 


# ---------------------------------------------------------------------------
#
# set up the proper reporting mode
#
# use these calls as needed for reporting:
#
# log.info("verbose message") 
# log.warning("warning message") 
# log.error("error message") 
#
# ---------------------------------------------------------------------------
if args.verbose == False:
    log.basicConfig(format="%(levelname)s: %(message)s")
else:
    log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
    log.info("Verbose output.")

# ---------------------------------------------------------------------------
#
# check options
#
# ---------------------------------------------------------------------------
if (args.sourcedir == "notDefined"):
    log.error("sourcedir not defined")
    sys.exit(APP_EXIT_ERROR)

if (args.endnotes and args.footnotes):
    log.error("both \'endnotes\' and \'footnotes\' have been requested. Choose one at a time, please.")
    sys.exit(APP_EXIT_ERROR)

# ---------------------------------------------------------------------------
#
# if it's a simple command, deal with it and exit
#
# ---------------------------------------------------------------------------
if (args.init == True):
    log.info("creating initial minuscript files in local directory")
    write_initial_files( "." )
    exit( 0 )

# ---------------------------------------------------------------------------
#
# determine if all necessary files exist
#     manuscript data describes the collection of chapters and scenes
#     author data describes the author of the manuscript
#
# ---------------------------------------------------------------------------

# manuscript data
fullpath = os.path.join( args.sourcedir, args.manuscriptfile )
log.info( "opening input file " + args.manuscriptfile )
log.info( "opening input file " + fullpath )
if os.path.isfile( fullpath ):
    with open( fullpath ) as manuscript_file:
        manuscript_data = json.load( manuscript_file )

        # check version number
        if float(manuscript_data["version"]) > APP_VERSION: 
            log.error( args.manuscriptfile + 
                " version later than minuscript version" )
            exit( APP_EXIT_ERROR ) 

        # TODO: make sure this data is there
        # set local variables using this data

        # unless overridden on command line use the data to define the 
        # name of the final output
        if ( args.manuscriptname == "notDefined" ):
            args.manuscriptname = \
                manuscript_data["manuscript"]["runningtitle"].lower()
else:
    log.error( args.manuscriptfile + " does not exist" )
    exit( APP_EXIT_ERROR ) 

# author data
fullpath = os.path.join( args.sourcedir, args.author )
log.info( "opening input file " + args.author )
log.info( "opening input file " + fullpath )
if os.path.isfile( fullpath ):
    with open( fullpath ) as author_file:
        author_data = json.load( author_file )

        # check version number
        if float(author_data["version"]) > APP_VERSION: 
            log.error( args.author + " version later than minuscript version" )
            exit( APP_EXIT_ERROR ) 
else:
    log.error( args.author + " does not exist" )
    exit( APP_EXIT_ERROR ) 

# operate on synopsis file, if requested
if (args.synopsis == True):
    fullpath = os.path.join( 
        args.sourcedir, APP_SCENESDIR, args.synopsisfile )
    log.info( "opening input file " + args.synopsisfile )
    log.info( "opening input file " + fullpath )
    if not os.path.isfile( fullpath ):
        log.error( args.synopsisfile + " does not exist" )
        exit( APP_EXIT_ERROR ) 

# ---------------------------------------------------------------------------
#
# query operations
#
# These are operations you want to do without creating a manuscript
#
# ---------------------------------------------------------------------------

if (args.scenelist):
    print(manuscript_data["manuscript"]["title"])
    print( " " )
    for chapter in manuscript_data["manuscript"]["chapters"]:
     if (not "state" in chapter or 
         ("state" in chapter) and (not chapter["state"] == "off")):

         print(chapter["title"])
         for scene in chapter["scenes"]:
             print("    " + scene)

    exit(0)

if (args.outline):
    print(manuscript_data["manuscript"]["title"])
    print( " " )
    for chapter in manuscript_data["manuscript"]["chapters"]:
     if (not "state" in chapter or 
         ("state" in chapter) and (not chapter["state"] == "off")):

         print( "- " + chapter["title"] )
         if ("desc" in chapter):
             print(chapter["desc"])
         print( " " )

    exit(0)

# ---------------------------------------------------------------------------
#
# create a directory in which to work, and copy converted files into them
# note that the original files are not altered in any way by this script
#
# ---------------------------------------------------------------------------

# create the working directory
log.info( "Creating scene files ..." )
if  not os.path.exists( APP_BUILDDIR ): 
    os.makedirs( APP_BUILDDIR ) 

for chapter in manuscript_data["manuscript"]["chapters"]:
    if (not "state" in chapter or 
        ("state" in chapter) and (not chapter["state"] == "off")):

        # get all the files that need to be converted
        allfiles = chapter["scenes"]
        # iterate through scenes
        for scene in allfiles:
            if scene.endswith(".pdf"): 
                # copy the file into the work dir
                log.info( APP_BUILDDIR + "/" + scene )
                command = APP_CP + " " + args.sourcedir + "/" + \
                        scene + " " + APP_BUILDDIR
                os.system( command )
            else:
                # translate the file into tex, and place it in the work dir 
    
                # first, add two blank lines to prevent multimarkdown from 
                # treating colons in the first lines as a key, value pair
                tmp_mdfile = \
                    os.path.join( args.sourcedir, APP_BUILDDIR, scene + ".md" ) 
                tmp_scfile = \
                    os.path.join( args.sourcedir, APP_SCENESDIR, scene + ".md" )
                with open( tmp_mdfile, 'w' ) as mdfile, open( tmp_scfile, 
                    'r') as scfile:
                    mdfile.write( "\n\n" )
                    mdfile.write( scfile.read() )
    
                log.info( os.path.join ( args.sourcedir, APP_BUILDDIR, scene + \
                    "." + APP_FORMAT_EXT ) )
                tmp_texfile = os.path.join( args.sourcedir, APP_BUILDDIR, 
                    scene + APP_FORMAT_EXT )
                command = APP_MMD + " -t " + APP_FORMAT + " " + tmp_mdfile + \
                    " > " + tmp_texfile
                os.system( command )

# if requested, handle the synopsis file as well 
if (args.synopsis == True):
    sfile = os.path.join( APP_BUILDDIR + "/synopsis.tex" )

    if os.path.exists( sfile ): 
        # translate the file into tex, and place it in the work dir 
        log.info( sfile ) 
        command = APP_MMD + " -t " + APP_FORMAT + " " + args.sourcedir + "/" + \
                APP_SCENESDIR + "/" + args.synopsisfile + " > " + sfile 
        os.system( command )
    else:
        log.error( "synopsis file does not exist" )    
        sys.exit(APP_EXIT_ERROR)

# ---------------------------------------------------------------------------
#
# helper function to convert numbers to words 
#
# The author posted this solution to the same question I had, so I'm using
#   with attribution. http://stackoverflow.com/questions/8982163/
#              how-do-i-tell-python-to-convert-integers-into-words
# ---------------------------------------------------------------------------
def numToWords(num,join=True):
    '''words = {} convert an integer number into words'''
    units = ['','one','two','three','four','five','six','seven','eight','nine']
    teens = ['','eleven','twelve','thirteen','fourteen','fifteen','sixteen', \
             'seventeen','eighteen','nineteen']
    tens = ['','ten','twenty','thirty','forty','fifty','sixty','seventy', \
            'eighty','ninety']
    words = []
    if num==0: words.append('zero')
    else:
        numStr = '%d'%num
        numStrLen = len(numStr)
        groups = int((numStrLen+2)/3)
        numStr = numStr.zfill(groups*3)
        for i in range(0,groups*3,3):
            h,t,u = int(numStr[i]),int(numStr[i+1]),int(numStr[i+2])
            g = groups-(i/3+1)
            if h>=1:
                words.append(units[h])
                words.append('hundred')
            if t>1:
                words.append(tens[t])
                if u>=1: words.append(units[u])
            elif t==1:
                if u>=1: words.append(teens[u])
                else: words.append(tens[t])
            else:
                if u>=1: words.append(units[u])
    if join: return ' '.join(words)
    return words

# ---------------------------------------------------------------------------
#
# round a number to the nearest tens 
#
# ---------------------------------------------------------------------------
def roundup(x):
    return int(math.ceil(x / 10.0)) * 10

# ---------------------------------------------------------------------------
#
# latex file support functions 
#
# ---------------------------------------------------------------------------

#
# writes a centered, bold all caps chapter header with the chapter number
#   as a word, and the chapter title on a second line below that
#
def latex_write_newchapter_command( out ):
    out.write("\\newcommand{\\newchapter}[1]\n")
    out.write("{\n")
    out.write("  \\stepcounter{chapter}\n")
    out.write("  \\newpage\n")
    out.write("  \\vspace*{3in}\n")
    out.write("  \\begin{center}\n")
    out.write("  \\begin{noindent}\n")
    out.write("\n")
    out.write("  \\textbf{" + get_chapter_name_string() + "}\n\n" ) 
    out.write("  \\textbf{#1}\n")
    out.write("  \\end{noindent}\n")
    out.write("  \\end{center}\n")
    out.write("  \\bigskip\n")
    out.write("}\n")

#
# writes a centered, bold all caps header with the word SYNOPSIS 
#   as a heading. chapter counter is not increased
#
def latex_write_synopsis_command( out ):
    out.write("\\newcommand{\\synopsis}\n")
    out.write("{\n")
    out.write("  \\newpage\n")
    out.write("  \\vspace*{3in}\n")
    out.write("  \\begin{center}\n")
    out.write("  \\begin{noindent}\n")
    out.write("\n")
    out.write("  \\textbf{SYNOPSIS}\n\n" ) 
    out.write("  \\textbf{}\n")
    out.write("  \\end{noindent}\n")
    out.write("  \\end{center}\n")
    out.write("  \\bigskip\n")
    out.write("}\n")

def get_chapter_name_string():
    return "CHAPTER \\NUMBERstringnum{\\value{chapter}}"

# ---------------------------------------------------------------------------
#
# create the manuscript tex file
#
# ---------------------------------------------------------------------------
log.info( "creating file " + APP_TEXFILE )
with open( APP_TEXFILE, 'w' ) as out:
    escaped_runningtitle = \
        manuscript_data["manuscript"]["runningtitle"].translate( \
        str.maketrans({"_":  r"\_"}))
    # write header
    out.write("\\documentclass[letterpaper,12pt,onecolumn]{article}\n")
    out.write("\n")
    out.write("\\newcounter{chapter}\n")
    out.write("\n")
    out.write("\\usepackage[page]{totalcount}\n")
    out.write("\\usepackage{underscore}\n")
    out.write("\\usepackage{fmtcount}\n")
    out.write("\\usepackage{fancyhdr}\n")
    out.write("\\usepackage{setspace}\n")
    out.write("\\usepackage[margin=1in]{geometry}\n")
    out.write("\\usepackage{ragged2e}\n")
    out.write("\\usepackage{footmisc}\n")
    out.write("\\usepackage{pdfpages}\n")
    out.write("\\usepackage{tocloft}\n")
    out.write("\\usepackage{tocstyle}\n")
    if ( args.endnotes == True ):
        out.write("\\usepackage{endnotes}\n")
    out.write("\n")
    out.write("\\renewcommand\\cftsecleader{\\cftdotfill{\\cftdotsep}}\n")
    out.write("\\renewcommand\\contentsname{}\n")
    out.write("\\renewcommand{\\emph}[1]{\\textit{#1}}\n")
    out.write("\\pagestyle{fancy}\n")
    out.write("\\fancyhead{}\n")
    out.write("\\fancyfoot{}\n")
    out.write("\\renewcommand{\\headrulewidth}{0pt}\n")
    if (args.footnotes == False):
        out.write("\\renewcommand{\\footnote}[1]{}\n")
    out.write("\\fancyhead[R]{\n")
    out.write("    \\fontsize{10}{12} \\fontfamily{" + args.fontfamily +
        "} \\selectfont ")
    out.write(author_data["author"]["surname"] + " / ")
    out.write("\\MakeUppercase{" + escaped_runningtitle + "} /" ) 
    out.write("\\thepage }\n")
    out.write("\n")
    if ( args.endnotes == True ):
        out.write("\\let\\footnote=\\endnote\n")
    out.write("\n")
    out.write("\\begin{document}\n")
    out.write("\\raggedright\n")
    out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% our preamble\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\fontfamily{" + args.fontfamily + "}\\selectfont\n")
    out.write("\\renewcommand\\footnotelayout{\\fontfamily{" + 
        args.fontfamily + "}\\selectfont}\n")
    out.write("\\setlength{\\parindent}{2.54cm}\n")
    out.write("%-----------------------------\n")
    out.write("\n")
    out.write("%\n")
    out.write("% commands\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\newcommand{\\wordcount}{approx. words: \\input{m.sum}}\n")
    out.write("\\newcommand{\\sceneseparator}\n")
    out.write("{\n")
    out.write("  \\begin{center}\\#\\#\\#\\end{center}\n")
    out.write("  \\vspace*{0.125in}\n")
    out.write("}\n")
    latex_write_newchapter_command( out )
    latex_write_synopsis_command( out )
    out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% this is the title page\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\thispagestyle{empty}\n")
    out.write("\\singlespacing\n")
    out.write("\\begin{noindent}\n")
    out.write("\\begin{minipage}{0.5\\linewidth}\n")
    out.write("\\flushleft\n")
    out.write(author_data["author"]["name"]    + "\\\\\n")
    out.write(author_data["author"]["address"] + "\\\\\n")
    out.write(author_data["author"]["city"]    + ", ")
    out.write(author_data["author"]["state"]   + " ")
    out.write(author_data["author"]["zip"]     + "\\\\\n")
    out.write(author_data["author"]["email"]   + "\\\\\n")
    out.write(author_data["author"]["phone"]   + "\n")
    out.write("\\end{minipage}\n")
    out.write("\\hfill\n")
    out.write("\\begin{minipage}{0.45\\linewidth}\n")
    out.write("\\flushright\n")
    if ( args.wordcount == True ):
        out.write("\wordcount\\\\\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\end{minipage}\n")
    out.write("\\end{noindent}\n")
    out.write("\n")
    out.write("\\doublespacing\n")
    out.write("\n")
    out.write("\\vspace*{3in}\n")
    out.write("\\begin{center}\n")
    out.write("\\textbf{\n")
    out.write(manuscript_data["manuscript"]["title"] + "\\\\\n")
    out.write("\\ \\newline\n")
    out.write("by\\\\\n")
    out.write(author_data["author"]["name"]    + "\\\\\n")
    out.write("}\n")
    out.write("\\end{center}\n")
    out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% the manuscript begins here ...\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\clearpage\n")
    out.write("\\newgeometry{left=1in,right=1in,top=1in,bottom=1in}\n")
    out.write("\\raggedright\n")
    out.write("\\setlength\parindent{0.5in}\n")
    out.write("\\doublespacing\n")
    out.write("\n")

    # this is how we number pages
    out.write("\\pagenumbering{roman}\n")
    out.write("\\setcounter{page}{1}\n")

    # write out the synopsis, if that's been requested
    if (args.synopsis == True):
        out.write("\\synopsis{}\n")
        # add synopsis 
        out.write("\\input{" + APP_BUILDDIR + "/synopsis.tex}\n")
        out.write("\n")

    # write out table of contents, if requested
    if ( args.toc == True ):
        out.write("\\newpage\n")
        out.write("{\n")
        out.write("\\begin{center}\n")
        out.write("\\textbf{Contents}\n")
        out.write("\\end{center}\n")
        out.write("\\tableofcontents\n")
        out.write("}\n")

    # iterate through chapters and scenes
    for chapter in manuscript_data["manuscript"]["chapters"]:
        if (not "state" in chapter or 
            ("state" in chapter) and (not chapter["state"] == "off")):
            # write chapters
            out.write("\\newchapter{" + chapter["title"] + "}\n")
            if ( args.toc == True ):
                out.write("  \\addcontentsline{toc}{section}{" + 
                    chapter["title"] + "}\n")

            # start the page numbering
            if APP_START_PAGE_NUMBERING:
                out.write("\\pagenumbering{arabic}\n")
                out.write("\\setcounter{page}{1}\n")
                APP_START_PAGE_NUMBERING = 0

            # write chapter synopsis, if that's been requested
            if ( args.chapsum == True ):
                if ("desc" in chapter):
                    out.write("\\begin{quote}\n")
                    out.write("\\textit{\n")
                    out.write("  \\begingroup\n")
                    out.write("  \\catcode`\\_=12\\relax\n")
                    out.write( chapter["desc"] )
                    out.write("  \\endgroup\n")
                    out.write("}\n\n")
                    out.write("\\end{quote}\n")
                    out.write("\\bigskip\n")

            # add scene references, and separators
            curscene = 0
            numscenes = len(chapter["scenes"])
            for scene in chapter["scenes"]:
                curscene += 1
                if scene.endswith(".pdf"): 
                    scene_name = os.path.basename( scene )
                    out.write("\\includepdf[pagecommand={\\pagestyle{fancy}},pages={1-},frame,scale=0.9]{" + APP_BUILDDIR + "/" + scene_name + "}\n")
                else:
                    out.write("\\begingroup\n")
                    out.write("\\catcode`\\_=12\\relax\n")
                    out.write("\\input{\"" + APP_BUILDDIR + "/" + \
                        scene + "\"}\n")
                    out.write("\\endgroup\n")
                    if (curscene != numscenes):
                        out.write("\\sceneseparator\n")
                        out.write("\n")
            out.write("\n")

    # end notes
    if ( args.endnotes == True ):
        out.write("\\clearpage\n")
        out.write("\\theendnotes\n")

    # end of document
    out.write("\n")
    out.write("\\end{document}\n")
    out.close()

# see if the file was written
if  not os.path.exists( APP_TEXFILE ): 
    log.error( "Did not create output file: " + APP_TEXFILE )    

# ---------------------------------------------------------------------------
#
# write out the manuscript pdf file 
#
# ---------------------------------------------------------------------------
if (args.nopdf == False):
    if ( args.wordcount == True ):
        os.system( "echo 0 > m.sum" )

    log.info( "Creating pdf file ..." )
    os.system( APP_LATEX + " manuscript.tex 2>/dev/null 1>/dev/null" ) 
    os.system( APP_LATEX + " manuscript.tex 2>/dev/null 1>/dev/null" ) 
    log.info( "creating manuscript " + args.manuscriptname + ".pdf" )
    os.system( "mv manuscript.pdf " + args.manuscriptname + ".pdf")

    # count the words
    if ( args.wordcount == True ):
        log.info( "performing wordcount" )
        os.system( "pdftops " + args.manuscriptname + ".pdf" )
        os.system( APP_PS2ASCII + " " + args.manuscriptname + ".ps | wc -w > m.sum" )
        os.system( APP_LATEX + " manuscript.tex 2>/dev/null 1>/dev/null" ) 
        os.system( APP_LATEX + " manuscript.tex 2>/dev/null 1>/dev/null" ) 
        os.system( "mv manuscript.pdf " + args.manuscriptname + ".pdf")
        # note: may need to open that file and round the number up, then
        # write it out again


# ---------------------------------------------------------------------------
#
# clean up
#
# ---------------------------------------------------------------------------
log.info( "Cleaning up ..." )
if args.debug == False:
    os.system( "rm -rf " + APP_BUILDDIR )
    os.system( 
        "rm -f manuscript.aux manuscript.ent manuscript.log manuscript.toc manuscript.tex manuscript.sum m.sum " + args.manuscriptname + ".ps" )

