#!/opt/local/bin/python

# ---------------------------------------------------------------------------
#
# minuscript, a minimal manuscript tool
#
# ---------------------------------------------------------------------------
"""
Copyright (c) 2016, David H. Rogers 
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 """
# ---------------------------------------------------------------------------

import argparse
import json
import os
import sys
import logging as log
import configparser
import textwrap

# ---------------------------------------------------------------------------
#
# global variables
#
# ---------------------------------------------------------------------------
# this application
APP_NAME        = "minuscript"
# APP_CONF_FILE   = os.path.expanduser("~/.minuscript/minuscript.conf")
APP_VERSION     = 1.0
APP_EXIT_ERROR  = 42
APP_BUILDDIR    = "minuscript_buildtemp"
APP_TOC_NAME    = "minuscript_toc"
APP_TOC_FILE    = APP_TOC_NAME + ".tex"
APP_TOC_CHAPTER = 1
APP_NUMWORDS    = 1000
APP_START_PAGE_NUMBERING = 1
# TODO: add global variable for 'scenes' directory

# external applications
APP_MMD         = "multimarkdown"
APP_LATEX       = "pdflatex"
APP_CP          = "cp"

# ---------------------------------------------------------------------------
#
# get initial settings from settings file, if there is one
#
# ---------------------------------------------------------------------------
conf_parser = argparse.ArgumentParser(
    # Turn off help, so we print all options in response to -h
    add_help=False
    )
# TODO: add global configuration file
# conf_parser.add_argument("-c", "--conf_file", default=APP_CONF_FILE,
#                             help="Specify config file")

args, remaining_argv = conf_parser.parse_known_args()

defaults = {
    "sourcedir" : "defaultSourcedir",
    "author"    : "defaultAuthor",
    }

# SHORT CIRCUIT
# currently not implementing this, until the following work correctly:
#   1. full command line options
#   2. run-in-the-directory mode, in which the script is run in a 
#      manuscript directory, and all the data is local
#
#if args.conf_file:
#    config = ConfigParser.SafeConfigParser()
#    config.readfp(open(args.conf_file))
#    defaults = dict(config.items("Default"))

# ---------------------------------------------------------------------------
#
# command line options
#
# ---------------------------------------------------------------------------
# Don't surpress add_help here so it will handle -h
parser = argparse.ArgumentParser(
    # Don't mess with format of description
    formatter_class=argparse.RawDescriptionHelpFormatter,
    # Inherit options from config_parser
    parents=[conf_parser],
    # print script description with -h/--help
    epilog=textwrap.dedent('''\
        examples:
        
          minuscript (no args)
            will use the current directory as the manuscript directory.
            expects appropriate files in the current directory.

          minuscript --synopsis 
            will use the current directory as the manuscript directory,
            and create a manuscript with a synopsis before the first
            chapter. Expects a file named synopsis.md in the scenes
            directory.

          minuscript --synopsis --synopsisfile new-synopsis.md
            will use the current directory as the manuscript directory,
            and create a manuscript with a synopsis before the first
            chapter. Expects a file named new-synopsis.md in the scenes
            directory.
            ''')
)
parser.set_defaults(**defaults)
parser.add_argument( "-d", "--debug", action="store_true", default=False,
    help="run in debug mode")
parser.add_argument( "-v", "--verbose", action="store_true", default=False,
    help="report verbosely")
# TODO: internal logic of notes and endnotes interfering with each other
parser.add_argument( "--author",
    help="read author data from this file")
parser.add_argument( "--endnotes", action="store_true", default=False,
    help="write internal notes as endnotes")
parser.add_argument( "--fontfamily", default="pcr", 
    help="define the font family for the resulting pdf")
parser.add_argument( "--manuscript", default="defaultMS", 
    help="name of the manuscript")
parser.add_argument( "--manuscriptfile", default="manuscript.json", 
    help="read manuscript definition from this file")
parser.add_argument( "--nopdf", action="store_true", default=False,
    help="don't create pdf file")
parser.add_argument( "--notes", action="store_true", default=False,
    help="write internal notes as footnotes")
parser.add_argument( "--output", default="manuscript.tex", 
    help="write output to this file")
parser.add_argument( "--sourcedir", 
    help="use this as the root directory for the manuscript")
parser.add_argument( "--synopsis", action="store_true", default=False,
    help="include synopsis before the first chapter")
parser.add_argument( "--synopsisfile", default="synopsis.md", 
    help="if requested, read synopsis from this file")
parser.add_argument( "--toc", action="store_true", default=False,
    help="create table of contents")
parser.add_argument( "--version", action="version", version=APP_VERSION)
parser.add_argument( "--wordcount", action="store_true", default=False,
    help="add wordcount to title page")

args = parser.parse_args(remaining_argv)

# ---------------------------------------------------------------------------
#
# if the manuscript hasn't been set, the user may have run it in the 
# manuscript directory, so look for files locally 
#
# ---------------------------------------------------------------------------
if ( args.manuscript == "defaultMS" ):  
    path, curdir = os.path.split( os.getcwd() )
    args.manuscript = curdir
    args.sourcedir = path

if ( args.author == "defaultAuthor" ):  
    args.author = "author.json" 


# ---------------------------------------------------------------------------
#
# set up the proper reporting mode
#
# use these calls as needed for reporting:
#
# log.info("verbose message") 
# log.warning("warning message") 
# log.error("error message") 
#
# ---------------------------------------------------------------------------
if args.verbose == False:
    log.basicConfig(format="%(levelname)s: %(message)s")
else:
    log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
    log.info("Verbose output.")

# ---------------------------------------------------------------------------
#
# check options
#
# ---------------------------------------------------------------------------
status = 1

if (args.sourcedir == "notDefined"):
    log.error("sourcedir not defined")
    status = 0

if (status == 0): 
    sys.exit(1)

# ---------------------------------------------------------------------------
#
# determine if all necessary files exist
#     manuscript data describes the collection of chapters and scenes
#     author data describes the author of the manuscript
#
# ---------------------------------------------------------------------------

# manuscript data
fullpath = os.path.join( args.sourcedir, args.manuscript, args.manuscriptfile )
log.info( "opening input file " + args.manuscriptfile )
log.info( "opening input file " + fullpath )
if os.path.isfile( fullpath ):
    with open( fullpath ) as manuscript_file:
        manuscript_data = json.load( manuscript_file )

        # check version number
        if float(manuscript_data["version"]) > APP_VERSION: 
            log.error( args.manuscriptfile + 
                " version later than minuscript version" )
            exit( APP_EXIT_ERROR ) 
else:
    log.error( args.manuscript + " does not exist" )
    exit( APP_EXIT_ERROR ) 

# author data
fullpath = os.path.join( args.sourcedir, args.manuscript, args.author )
log.info( "opening input file " + args.author )
log.info( "opening input file " + fullpath )
if os.path.isfile( fullpath ):
    with open( fullpath ) as author_file:
        author_data = json.load( author_file )

        # check version number
        if float(author_data["version"]) > APP_VERSION: 
            log.error( args.author + " version later than minuscript version" )
            exit( APP_EXIT_ERROR ) 
else:
    log.error( args.author + " does not exist" )
    exit( APP_EXIT_ERROR ) 

# synopsis file, if requested
if (args.synopsis == True):
    fullpath = os.path.join( 
        args.sourcedir, args.manuscript, "scenes", args.synopsisfile )
    log.info( "opening input file " + args.synopsisfile )
    log.info( "opening input file " + fullpath )
    if not os.path.isfile( fullpath ):
        log.error( args.synopsisfile + " does not exist" )
        exit( APP_EXIT_ERROR ) 


# ---------------------------------------------------------------------------
#
# create a directory in which to work, and copy converted files into them
# note that the original files are not altered in any way by this script
#
# ---------------------------------------------------------------------------

# create the working directory
log.info( "Creating scene files ..." )
if  not os.path.exists( APP_BUILDDIR ): 
    os.makedirs( APP_BUILDDIR ) 

# TODO: generalize 'latex' and 'tex' values to APP_ values
format = "latex"
extension = "tex"
for chapter in manuscript_data["manuscript"]["chapters"]:
    for scene in chapter["scenes"]:
        if scene.endswith(".pdf"): 
            # copy the file into the work dir
            log.info( APP_BUILDDIR + "/" + scene )
            command = APP_CP + " " + args.sourcedir + "/" + \
                    args.manuscript + "/" + scene + " " + APP_BUILDDIR
            os.system( command )
        else:
            # translate the file into tex, and place it in the work dir 
            log.info( APP_BUILDDIR + "/" + scene + "." + extension )
            command = APP_MMD + " -t " + format + " " + args.sourcedir + "/" + \
                    args.manuscript + "/scenes/" + scene + ".md > " + \
                    APP_BUILDDIR + "/" + scene + "." + extension
            os.system( command )

# TODO: check for existence of the synopsis file
# optionally do this for synopsis as well
if (args.synopsis == True):
    # translate the file into tex, and place it in the work dir 
    log.info( APP_BUILDDIR + "/synopsis.tex" )
    command = APP_MMD + " -t " + format + " " + args.sourcedir + "/" + \
            args.manuscript + "/scenes/" + args.synopsisfile + " > " + \
            APP_BUILDDIR + "/synopsis.tex"
    os.system( command )

# ---------------------------------------------------------------------------
#
# helper function to convert numbers to words 
#
# The author posted this solution to the same question I had, so I'm using
#   with attribution. http://stackoverflow.com/questions/8982163/
#              how-do-i-tell-python-to-convert-integers-into-words
# ---------------------------------------------------------------------------
def numToWords(num,join=True):
    '''words = {} convert an integer number into words'''
    units = ['','one','two','three','four','five','six','seven','eight','nine']
    teens = ['','eleven','twelve','thirteen','fourteen','fifteen','sixteen', \
             'seventeen','eighteen','nineteen']
    tens = ['','ten','twenty','thirty','forty','fifty','sixty','seventy', \
            'eighty','ninety']
    words = []
    if num==0: words.append('zero')
    else:
        numStr = '%d'%num
        numStrLen = len(numStr)
        groups = int((numStrLen+2)/3)
        numStr = numStr.zfill(groups*3)
        for i in range(0,groups*3,3):
            h,t,u = int(numStr[i]),int(numStr[i+1]),int(numStr[i+2])
            g = groups-(i/3+1)
            if h>=1:
                words.append(units[h])
                words.append('hundred')
            if t>1:
                words.append(tens[t])
                if u>=1: words.append(units[u])
            elif t==1:
                if u>=1: words.append(teens[u])
                else: words.append(tens[t])
            else:
                if u>=1: words.append(units[u])
    if join: return ' '.join(words)
    return words

# ---------------------------------------------------------------------------
#
# latex file support functions 
#
# ---------------------------------------------------------------------------

#
# writes a centered, bold all caps chapter header with the chapter number
#   as a word, and the chapter title on a second line below that
#
def latex_write_newchapter( out ):
    out.write("\\newcommand{\\newchapter}[1]\n")
    out.write("{\n")
    out.write("  \\stepcounter{chapter}\n")
    out.write("  \\newpage\n")
    out.write("  \\vspace*{3in}\n")
    out.write("  \\begin{center}\n")
    out.write("  \\begin{noindent}\n")
    out.write("\n")
    out.write("  \\textbf{" + get_chapter_name_string() + "}\n\n" ) 
    out.write("  \\textbf{#1}\n")
    out.write("  \\end{noindent}\n")
    out.write("  \\end{center}\n")
    out.write("  \\bigskip\n")
    out.write("}\n")

#
# writes a centered, bold all caps header with the word SYNOPSIS 
#   as a heading. chapter counter is not increased
#
def latex_write_synopsis( out ):
    out.write("\\newcommand{\\synopsis}\n")
    out.write("{\n")
    out.write("  \\newpage\n")
    out.write("  \\vspace*{3in}\n")
    out.write("  \\begin{center}\n")
    out.write("  \\begin{noindent}\n")
    out.write("\n")
    out.write("  \\textbf{SYNOPSIS}\n\n" ) 
    out.write("  \\textbf{}\n")
    out.write("  \\end{noindent}\n")
    out.write("  \\end{center}\n")
    out.write("  \\bigskip\n")
    out.write("}\n")

def get_chapter_name_string():
    return "CHAPTER \\NUMBERstringnum{\\value{chapter}}"

# ---------------------------------------------------------------------------
#
# create the manuscript tex file
#
# ---------------------------------------------------------------------------
log.info( "creating file " + args.output )
with open( args.output, 'w' ) as out:
    # create table of contents, if needed
    if ( args.toc == True ):
        log.info( "Creating toc file ..." )
        toc = open(APP_BUILDDIR + "/" + APP_TOC_FILE, "w" )
        toc.write("%\n")
        toc.write("% table of contents file\n")
        toc.write("%\n")
        toc.write("\\newgeometry{left=1.5in,right=1.5in,top=1in,bottom=1in}\n")
        toc.write("\\doublespacing\n")
        toc.write("\\vspace*{1in}\n")
        toc.write("\\begin{center}\n")
        toc.write("\\textbf{TABLE OF CONTENTS}\n")
        toc.write("\\end{center}\n")
        toc.write("\n")
        toc.write("\\begin{flushleft}\n")
        toc.write("\\begin{noindent}\n")
        toc.write("\\begin{tabular}{ p{2in} p{3in} }\n")

    # write header
    out.write("\\documentclass[letterpaper,12pt,onecolumn]{article}\n")
    out.write("\n")
    out.write("\\newcounter{chapter}\n")
    out.write("\n")
    out.write("\\usepackage[page]{totalcount}\n")
    out.write("\\usepackage{fmtcount}\n")
    out.write("\\usepackage{fancyhdr}\n")
    out.write("\\usepackage{setspace}\n")
    out.write("\\usepackage[margin=1in]{geometry}\n")
    out.write("\\usepackage{ragged2e}\n")
    out.write("\\usepackage{footmisc}\n")
    out.write("\\usepackage{pdfpages}\n")
    if ( args.endnotes == True ):
        out.write("\\usepackage{endnotes}\n")
    out.write("\n")
    out.write("\\renewcommand{\\emph}[1]{\\textit{#1}}\n")
    out.write("\\pagestyle{fancy}\n")
    out.write("\\fancyhead{}\n")
    out.write("\\fancyfoot{}\n")
    out.write("\\renewcommand{\\headrulewidth}{0pt}\n")
    if (args.notes == False):
        out.write("\\renewcommand{\\footnote}[1]{}\n")
    out.write("\\fancyhead[R]{\n")
    out.write("    \\fontsize{10}{12} \\fontfamily{" + args.fontfamily +
        "} \\selectfont ")
    out.write(author_data["author"]["surname"] + " / ")
    out.write("\\MakeUppercase{" + 
        manuscript_data["manuscript"]["runningtitle"] + "} / ")
    out.write("\\thepage }\n")
    out.write("\n")
    if ( args.endnotes == True ):
        out.write("\\let\\footnote=\\endnote\n")
    out.write("\n")
    out.write("\\begin{document}\n")
    out.write("\\raggedright\n")
    out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% our preamble\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\fontfamily{" + args.fontfamily + "}\\selectfont\n")
    out.write("\\renewcommand\\footnotelayout{\\fontfamily{" + 
        args.fontfamily + "}\\selectfont}\n")
    out.write("\\setlength{\\parindent}{2.54cm}\n")
    out.write("%-----------------------------\n")
    out.write("\n")
    out.write("%\n")
    out.write("% commands\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\newcommand{\\sceneseparator}\n")
    out.write("{\n")
    out.write("  \\begin{center}\\#\\#\\#\\end{center}\n")
    out.write("  \\vspace*{0.125in}\n")
    out.write("}\n")
    latex_write_newchapter( out )
    latex_write_synopsis( out )
    out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% this is the title page\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\thispagestyle{empty}\n")
    out.write("\\singlespacing\n")
    out.write("\\begin{noindent}\n")
    out.write("\\begin{minipage}{0.5\\linewidth}\n")
    out.write("\\flushleft\n")
    out.write(author_data["author"]["name"]    + "\\\\\n")
    out.write(author_data["author"]["address"] + "\\\\\n")
    out.write(author_data["author"]["city"]    + ", ")
    out.write(author_data["author"]["state"]   + " ")
    out.write(author_data["author"]["zip"]     + "\\\\\n")
    out.write(author_data["author"]["email"]   + "\\\\\n")
    out.write(author_data["author"]["phone"]   + "\n")
    out.write("\\end{minipage}\n")
    out.write("\\hfill\n")
    out.write("\\begin{minipage}{0.45\\linewidth}\n")
    out.write("\\flushright\n")
    if ( args.wordcount == True ):
        out.write("wordcount 1000 \\\\\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\ \\newline\n")
    out.write("\\end{minipage}\n")
    out.write("\\end{noindent}\n")
    out.write("\n")
    out.write("\\doublespacing\n")
    out.write("\n")
    out.write("\\vspace*{3in}\n")
    out.write("\\begin{center}\n")
    out.write("\\textbf{\n")
    out.write(manuscript_data["manuscript"]["title"] + "\\\\\n")
    out.write("\\ \\newline\n")
    out.write("by\\\\\n")
    out.write(author_data["author"]["name"]    + "\\\\\n")
    out.write("}\n")
    out.write("\\end{center}\n")
    out.write("\n")
    out.write("\\pagenumbering{roman}\n")
    out.write("\\setcounter{page}{1}\n")
    if ( args.toc == True ):
        out.write("%-----------------------------\n")
        out.write("%\n")
        out.write("% table of contents\n" )
        out.write("%\n")
        out.write("%-----------------------------\n")
        out.write("\\newpage\n")
        out.write("\input{" + APP_BUILDDIR + "/" + APP_TOC_NAME + "}\n")
        out.write("\n")
    out.write("%-----------------------------\n")
    out.write("%\n")
    out.write("% the manuscript begins here ...\n")
    out.write("%\n")
    out.write("%-----------------------------\n")
    out.write("\\clearpage\n")
    out.write("\\newgeometry{left=1in,right=1in,top=1in,bottom=1in}\n")
    out.write("\\raggedright\n")
    out.write("\\setlength\parindent{0.5in}\n")
    out.write("\\doublespacing\n")
    out.write("\n")

    # write out the synopsis, if that's been requested
    if (args.synopsis == True):
        out.write("\\synopsis{}\n")
        # add synopsis 
        out.write("\input{" + APP_BUILDDIR + "/synopsis.tex}\n")
        out.write("\n")

        # optionally, write an entry int the table of contents
        if ( args.toc == True ):
            toc.write("\\textbf{SYNOPSIS} \\\\\n")

    # iterate through chapters and scenes
    for chapter in manuscript_data["manuscript"]["chapters"]:
        # start the page numbering, and start writing the chapters
        out.write("\\newchapter{" + chapter["title"] + "}\n")
        if APP_START_PAGE_NUMBERING:
            out.write("\\pagenumbering{arabic}\n")
            out.write("\\setcounter{page}{1}\n")
            APP_START_PAGE_NUMBERING = 0

        # create an entry in the table of contents
        if ( args.toc == True ):
            toc.write("\\textbf{CHAPTER " + 
                numToWords(APP_TOC_CHAPTER).upper() + ":} &" + 
                chapter["title"] + "\\\\\n")
            APP_TOC_CHAPTER += 1

        # add scene references, and separators
        curscene = 0
        numscenes = len(chapter["scenes"])
        for scene in chapter["scenes"]:
            curscene += 1
            if scene.endswith(".pdf"): 
                scene_name = os.path.basename( scene )
                out.write("\includepdf[frame,noautoscale,scale=0.9]{" + 
                    APP_BUILDDIR + "/" + scene_name + "}\n")
            else:
                out.write("\input{" + APP_BUILDDIR + "/" + scene + "}\n")
            if (curscene != numscenes):
                out.write("\\sceneseparator\n")
                out.write("\n")
        out.write("\n")

    # end notes
    if ( args.endnotes == True ):
        out.write("\\clearpage\n")
        out.write("\\theendnotes\n")

    # finish table of contents
    if ( args.toc == True ):
        toc.write("\\end{tabular}\n")
        toc.write("\\end{noindent}\n")
        toc.write("\\end{flushleft}\n")
        toc.write("\\restoregeometry\n")
        toc.close()

    # end of document
    out.write("\n")
    out.write("\\end{document}\n")
    out.close()

# see if the file was written
if  not os.path.exists( args.output ): 
    log.error( "Did not create output file: " + args.output )    

# ---------------------------------------------------------------------------
#
# write out the manuscript pdf file 
#
# ---------------------------------------------------------------------------
if (args.nopdf == False):
    log.info( "Creating pdf file ..." )
    os.system( APP_LATEX + " manuscript.tex 2>/dev/null 1>/dev/null" ) 
    os.system( "mv manuscript.pdf " + args.manuscript + ".pdf")

# ---------------------------------------------------------------------------
#
# clean up
#
# ---------------------------------------------------------------------------
log.info( "Cleaning up ..." )
if args.debug == False:
    os.system( "rm -rf " + APP_BUILDDIR )
    os.system( 
        "rm -f manuscript.aux manuscript.ent manuscript.log manuscript.tex" )

